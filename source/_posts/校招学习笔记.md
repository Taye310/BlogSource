---
title: 校招学习笔记
date: 2019-09-16 16:41:40
tags: 
    - 刷题
---

# 笔试

## 知识点

[github](https://github.com/huihut/interview)

**二叉树计算公式总结：**  
1. n个节点的二叉树一共有((2n)!)/(n! * (n+1)!)种
2. n层二叉树的第n层最多为2^(n-1)个
3. 二叉树节点计算公式 N = n0+n1+n2，度为0的叶子节点比度为2的节点数多一个。N=1*n1+2*n2+1
4. 对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1
5. 具有n个节点的完全二叉树的深度为log2(n) + 1

**图计算公式总结：**  
N个点的无向完全图边数为：N*（N-1）/2；先手获胜必须总数为奇数；
N=1,2,3,......,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。

> **无向图：**  
遍历：DFS用栈 / BFS用队列  
邻接矩阵法存图 占用空间与什么有关  
在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。  
A,边的条数为C（n,2）=n(n-1)/2  
B,G是完全图，必定是连通图。所以连通分量只有其自身  
C，G是完全图，必定是连通图  
D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)  

> **无向带权图的最小生成树算法——Prim及Kruskal算法思路**  
 带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。

> **广义表：**  
head() 返回列表的第一个元素；
tail() 返回列表的删去第一个元素之后的剩余列表；  

> **hash：**  
装填因子：对5个对象进行hash,而内存中，准备了20个位置，那么还有15个空位，最后装填因子就是5/20 = 0.25，所以装填因子越小，产生冲突的可能越小。  
1、hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询  
因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。  
2、hash索引无法被用来进行数据的排序操作  
由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。  
3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。  
4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。  
对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。  

> **循环队列：**  
front=rear意味着队空或者队满，再入队或者出队就要上溢或者下溢了  

> **杂项：**  
KMP算法：一种不舍弃之前匹配信息的字符串匹配算法，时间复杂度O(m+n) 其中*next[j]就是第j个元素前j-1个元素首尾重合部分个数加一*  
输出受限的双端队列,即删除限制在一端进行,而插入仍允许在两端进行.  


# 面试

项目经历的star原则 p6  

# 面经复盘

## 字节跳动--游戏研发

![jrtt1](校招学习笔记/jrtt1.jpg)

1. 
```
指针常量：int * const p
常量指针：const int * p
```

2. 判断扇形区域内  
算两点距离（半径） 算两向量夹角  

3. 一万个球，知道圆心位置和半径，如何预处理/数据结构存储，新加球可以最少次数判断是否相交  
TODO  

4. 4个人分100金币，第一个人怎么分半数以上人同意（智力题？）  
给第三个人一个金币，不然他一个也拿不到  

5. 无向图连通最小花费：最小生成树（prime，keruskal）//有向图最短路径（单源dijstra，多源floyd）  
```
prime(加点法):每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。  
kruskal(加边法):初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

dijkstra：类似prime

floyd多源最短路径：动态规划Dis(i,j) = Dis(i,k) + Dis(k,j)
```

6. 字符串以词为单位反转  
两个栈  

7. 顶点着色器/片元着色器作用/什么是片元  
```
顶点着色器：分为输入和输出两部分,负责的功能是把输入的数据进行矩阵变换位置,计算光照公式生成逐顶点颜⾊,⽣成/变换纹理坐标.并且把位置和纹理坐标这样的参数发送到片段着色器.  
片元着色器：处理由光栅化阶段生成的每个片元，最终计算出每个像素的最终颜色。归根结底，实际上就是数据的集合。这个数据集合包含每一个像素的各个颜色分量和像素透明度的值。

*光栅化*，就是计算出1920×1080这么长的RGB数组中，每一个RGB的值

3D场景中将三角形作为基本*图元*

片元是光栅化过程的产物；光栅化是将一个图元转变为一个二维图象，二维图象上每个点都包含了颜色、深度和纹理数据，将该点和相关信息叫做一个片元
```

设计模式！工厂/观察者/策略模式？  
工厂模式：调用工厂只管给个名字，工厂里根据名字实例化对应的对象（选对应接口）；解决了接口选择的问题，拓展方便。

观察者模式：mvc，子类继承一个update方法，使用者在notify所有监听的子类时调用基类update

策略模式：核心是有个context，根据构造函数实例化了strategy的具体一种子类作为context的成员，因此context.excuteStrategy()可以调用context里的特定的strategy实例的doStrategy方法

stl里的trace？  
trace()函数？调试用的

工厂模式有几种？？  
3：简单工厂/工厂模式/抽象工厂（工厂的工厂）

光照模型公式  
```
3D渲染中， 物体表面的光照计算公式为：

I = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);

其中，环境光(ambient)计算公式为：

Iambient = Aintensity * Acolor ; (Aintensity表示环境光强度，Acolor表示环境光颜色)

漫反射光(diffuse)计算公式为：

Idiffuse = Dintensity*Dcolor*N·L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) ps:点乘是投影

镜面光照(specular)计算公式为：

Ispecular = Sintensity*Scolor*(R·V)n ; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)

综上所得：整个光照公式为：

I = Aintensity * Acolor + Dintensity*Dcolor*N.L + Sintensity*Scolor*(R.V)n ;

将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：

I = A + D*N.L + (R.V)n

```

类的内存结构  
[link](https://blog.csdn.net/fenxinzi557/article/details/51995911)  
记得字节对齐
```
char c;
int i; //是8字节 因为int之前的要对齐到int的4字节
```
类中有虚函数 要+4字节 因为有虚函数表  函数本身不占字节
继承的子类要先放父类的数据拷贝  

1. 对于基类，如果有虚函数，那么先存放虚函数表指针，然后存放自己的数据成员；如果没有虚函数，那么直接存放数据成员。 
2. 对于单一继承的类对象，先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据。 
3. 虚函数表中，先存放父类的虚函数，再存放子类的虚函数 
4. 如果重载了父类的某些虚函数，那么新的虚函数将虚函数表中父类的这些虚函数覆盖。 
5. 对于多重继承，先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，一次类推，最后存放自己的数据成员。其中每一个父类拷贝都包含一个虚函数表指针。如果子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。 
6. 当对象的虚函数被调用是，编译器去查询对象的虚函数表，找到该函数，然后调用。

构造函数/析构函数/虚函数  



![jrtt2](校招学习笔记/jrtt3.jpg)

信号量  

死锁  

进程/线程区别 PCB TCB

![jrtt3](校招学习笔记/jrtt2.jpg)

80个球找轻的  

64个人，提前准备名单卡片来确认是哪个人  

九宫格密码解锁的所有可能，大于等于四位数