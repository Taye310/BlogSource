---
title: 校招学习笔记
date: 2019-09-16 16:41:40
password: 456654
tags: 
    - 刷题
---

# 笔试

## C++

[C++ & C#/Unity notebook](https://taye310.github.io/2019/02/18/lang-notebook/)

## 知识点

[github](https://github.com/huihut/interview)

**十大排序**

堆排序，构建最大/最小堆时：
1. 父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）
2. 左孩子索引：2*i+1
3. 右孩子索引：2*i+2

稳定性：稳定性是一个特别重要的评估标准。稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之不稳定的排序算法经常会改变这个次序,这是我们不愿意看到的。

**查找算法**


**动态规划**
[详解](https://mp.weixin.qq.com/s/yEfrTK7UhRN0XX0_FVLyGA)

**时间复杂度计算：**
[参考资料](https://blog.csdn.net/kun1280437633/article/details/80770296)  

对数阶怎么来的：循环的时候i不是+常数来的，是i=i*2这样乘来的就是对数阶复杂度了  
```
for(i<100) i=i*2;
```
$i^2=100$ -> $O(log_{2}100)$ 

**二叉树计算公式总结：**  
1. n个节点的二叉树一共有((2n)!)/(n! * (n+1)!)种
2. n层二叉树的第n层最多为2^(n-1)个
3. 二叉树节点计算公式 N = n0+n1+n2，度为0的叶子节点比度为2的节点数多一个。N=1*n1+2*n2+1
4. 对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1
5. 具有n个节点的完全二叉树的深度为log2(n) + 1

**图计算公式总结：**  
N个点的无向完全图边数为：N*（N-1）/2；先手获胜必须总数为奇数；
N=1,2,3,......,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。

> **无向图：**  
遍历：DFS用栈 / BFS用队列  
邻接矩阵法存图 占用空间与什么有关  
在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。  
A,边的条数为C（n,2）=n(n-1)/2  
B,G是完全图，必定是连通图。所以连通分量只有其自身  
C，G是完全图，必定是连通图  
D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)  

> **无向带权图的最小生成树算法——Prim及Kruskal算法思路**  
 带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。

> **广义表：**  
head() 返回列表的第一个元素；
tail() 返回列表的删去第一个元素之后的剩余列表；  

> **hash：**  
装填因子：对5个对象进行hash,而内存中，准备了20个位置，那么还有15个空位，最后装填因子就是5/20 = 0.25，所以装填因子越小，产生冲突的可能越小。  
1、hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询  
因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。  
2、hash索引无法被用来进行数据的排序操作  
由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。  
3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。  
4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。  
对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。  

> **循环队列：**  
front=rear意味着队空或者队满，再入队或者出队就要上溢或者下溢了  

> **杂项：**  
KMP算法：一种不舍弃之前匹配信息的字符串匹配算法，时间复杂度O(m+n) 其中*next[j]就是第j个元素前j-1个元素首尾重合部分个数加一*  
输出受限的双端队列,即删除限制在一端进行,而插入仍允许在两端进行.  

## leetcode刷题

109. 有序链表转换二叉搜索树
     快慢指针加递归 每次递归，都是把链表分成两段；前面的那个链表末尾必须要加上nullptr，才算是分成了两个链表。

56. 合并区间
    push_back 和 emplace_back的区别，e更好 因为少一个构造函数

712. 两个字符串的最小ascii删除和
     DP LCS 最长公共子序列（Longest Common Sequence）
     最优子结构/重叠子问题（用dp就是查表得到的不用重新计算）

407. 接雨水2

208. 实现前缀树

**剑指offer系列：**  
size_t: 与int固定四个字节不同有所不同,size_t的取值range是目标平台下最大可能的数组尺寸,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int. 使用Int既有可能浪费，又有可能范围不够大。  
```
string replaceSpace(string s) {
    size_t pos;
    while(true){
        pos = s.find(" ");
        if(pos<string::npos){
            s.replace(pos,1,"%20");
        }else{
            break;
        }
    }
    return s;
}
```

面试题16. 数值的整数次方： 可以用位运算，$3^5 = 3^{101_{2}} = 3^{2^2+2^0} = 9^2*3^1$  

vector的insert方法使用迭代器参数可以用来合并vector  

```
while(!s.empty()&&pos<popped.size()&&popped[pos] == s.top()){//三个条件的顺序很重要
```

中序遍历用 栈

## 牛客刷题

union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，并且需要内存对齐  

c++的类体中，方法以外的区域不允许有初始化，简单类型是可以的，但是有构造函数的复杂对象则不行了，比如string对象！
```
error,expected identifier before numeric constant
```


# 面试

项目经历的star原则 p6  

# 面经复盘

## 字节跳动--游戏研发

<div style="width:300px">
    {% asset_img jrtt1.jpg %}
</div>

1. 
```
指针常量：int * const p
常量指针：const int * p
```

2. 判断扇形区域内  
算两点距离（半径） 算两向量夹角  

3. 一万个球，知道圆心位置和半径，如何预处理/数据结构存储，新加球可以最少次数判断是否相交  
TODO  

4. 4个人分100金币，第一个人怎么分半数以上人同意（智力题？）  
给第三个人一个金币，不然他一个也拿不到  

5. 无向图连通最小花费：最小生成树（prime，keruskal）//有向图最短路径（单源dijstra，多源floyd）  
```
prime(加点法):每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。  
kruskal(加边法):初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

dijkstra：类似prime

floyd多源最短路径：动态规划Dis(i,j) = Dis(i,k) + Dis(k,j)
```

6. 字符串以词为单位反转  
两个栈  

7. 顶点着色器/片元着色器作用/什么是片元  
```
顶点着色器：分为输入和输出两部分,负责的功能是把输入的数据进行矩阵变换位置,计算光照公式生成逐顶点颜⾊,⽣成/变换纹理坐标.并且把位置和纹理坐标这样的参数发送到片段着色器.  
片元着色器：处理由光栅化阶段生成的每个片元，最终计算出每个像素的最终颜色。归根结底，实际上就是数据的集合。这个数据集合包含每一个像素的各个颜色分量和像素透明度的值。

*光栅化*，就是计算出1920×1080这么长的RGB数组中，每一个RGB的值

3D场景中将三角形作为基本*图元*

片元是光栅化过程的产物；光栅化是将一个图元转变为一个二维图象，二维图象上每个点都包含了颜色、深度和纹理数据，将该点和相关信息叫做一个片元
```

设计模式！工厂/观察者/策略模式？  
工厂模式：调用工厂只管给个名字，工厂里根据名字实例化对应的对象（选对应接口）；解决了接口选择的问题，拓展方便。

观察者模式：mvc，子类继承一个update方法，使用者在notify所有监听的子类时调用基类update

策略模式：核心是有个context，根据构造函数实例化了strategy的具体一种子类作为context的成员，因此context.excuteStrategy()可以调用context里的特定的strategy实例的doStrategy方法

stl里的trace？  
trace()函数？调试用的

工厂模式有几种？？  
3：简单工厂/工厂模式/抽象工厂（工厂的工厂）

光照模型公式  
```
3D渲染中， 物体表面的光照计算公式为：

I = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);

其中，环境光(ambient)计算公式为：

Iambient = Aintensity * Acolor ; (Aintensity表示环境光强度，Acolor表示环境光颜色)

漫反射光(diffuse)计算公式为：

Idiffuse = Dintensity*Dcolor*N·L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) ps:点乘是投影

镜面光照(specular)计算公式为：

Ispecular = Sintensity*Scolor*(R·V)n ; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)

综上所得：整个光照公式为：

I = Aintensity * Acolor + Dintensity*Dcolor*N.L + Sintensity*Scolor*(R.V)n ;

将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：

I = A + D*N.L + (R.V)n

```

类的内存结构  
[link](https://blog.csdn.net/fenxinzi557/article/details/51995911)  
记得字节对齐
```
char c;
int i; //是8字节 因为int之前的要对齐到int的4字节
```
类中有虚函数 要+4字节 因为有虚函数表  函数本身不占字节
继承的子类要先放父类的数据拷贝  

1. 对于基类，如果有虚函数，那么先存放虚函数表指针，然后存放自己的数据成员；如果没有虚函数，那么直接存放数据成员。 
2. 对于单一继承的类对象，先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据。 
3. 虚函数表中，先存放父类的虚函数，再存放子类的虚函数 
4. 如果重载了父类的某些虚函数，那么新的虚函数将虚函数表中父类的这些虚函数覆盖。 
5. 对于多重继承，先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，一次类推，最后存放自己的数据成员。其中每一个父类拷贝都包含一个虚函数表指针。如果子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。 
6. 当对象的虚函数被调用是，编译器去查询对象的虚函数表，找到该函数，然后调用。

构造函数/析构函数/虚函数  

**在构造/析构函数中调用虚函数：** effective c++ 条款9：永远不要在构造函数或析构函数中调用虚函数

<div style="width:300px">
    {% asset_img jrtt3.jpg %}
</div>

>> 信号量  

>> 死锁  

>> 进程/线程区别 PCB TCB
1. 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
2. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

<div style="width:300px">
    {% asset_img jrtt2.jpg %}
</div>
>> 80个球找轻的  

>> 64个人，提前准备名单卡片来确认是哪个人  

>> 九宫格密码解锁的所有可能，大于等于四位数

## 网易雷火--牛客网

问简历内容  
游戏内AI如何实现：有限状态机，行为树  
一个UI被点击后发生了什么：  
  
**基础相关：**  
C++虚函数机制，虚表，虚指针：  
虚函数实在派生类可以覆写的函数，虚表存在于类内存中，记录了所有虚函数，每个虚表对应一个虚指针指向它  

构造函数可以是虚函数吗？  
不可以，虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。  

>> C# 内存模型 堆和栈  
[link](https://www.cnblogs.com/omg24/p/4202992.html)  
<div style="width:400px">
    {% asset_img valueandref.png %}
</div>
[link2](https://www.cnblogs.com/xiaodongy/p/7989711.html)

C# gc 值类型与引用类型  
注：Ref和Out的区别在于Ref在传递前需要初始化。  
值类型在栈上，引用类型在堆上；前者不需要gc，后者需要  
close()可以再open，dispose()后资源被标记为无用，等待gc回收  
非托管资源需要在程序中显式释放  
对象间相互引用导致了gc丧失实时性，变为不确定的方式，否则可以用引用计数这种方法判断对象是否无用  
GC清理垃圾实际上就是调用析构函数  
String对象是不可变的（只读），一旦创建不可改变，看似修改其实是返回了一个新对象  

[随机在圆上生成n个点，这n个点在同一半圆的概率是多少？](https://blog.csdn.net/zmazon/article/details/8547278)


lua闭包  
内部（子）函数可以使用外部（父）函数的局部变量
``` lua
function test()
    local i=0
    return function() --尾调用
        i+=1
        return i
    end
end
c1=test()
c2=test() --c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包
          --闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包
print(c1()) -->1
print(c1()) -->2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经
print(c2())    -->1//闭包不同所以upvalue不同    
print(c2()) -->2
```

lua怎么实现面向对象  
[lua作者的方法](http://www.lua.org/pil/16.html)  
object：用table做  
    table后边也可以用冒号（是个语法糖，剩了传self/this
    ```
        a.deposit(a,100) == a:deposit(100)
    ```
    ）  
    ``` lua
    function Account:withdraw (v)
        self.balance = self.balance - v
        end
    ```  
class：setmetatable  
``` lua
setmetatable(a, {__index = b}) --b是object a的class
```  
实现继承和重载
[风云的方法](https://blog.codingnow.com/2006/06/oo_lua.html)  
只定义一个class函数  
table [参考资料](https://www.cnblogs.com/msxh/p/8469340.html)  

>> 算法：最长公共子字符串（动态规划）  
状态转移方程$dp[i,j] = dp[i+1,j+1] + 1$ 用滚动数组可以省内存，优化

>> 算法：n叉树子节点值的和最大，规则不能同时取相邻的节点  

>> 渲染管线  

**二面：**  
实习经历相关  

游戏框架、设计模式  

值类型与引用类型 引用类型创建慢的原因，具体到内存  

博客上的文章 提了问题  

手写二分查找  

斐波那契数列递归与非递归写法 怎么优化  

有什么要问的  

## 字节跳动——牛客



# 企业列表

[资源链接](https://www.nowcoder.com/discuss/364482)

|领域|名称|网址|备注|
|---|---|---|---|
|监管机关|中国人民银行||软件开发、信用卡中心|
||银监会||
||保监会||
||证监会||
|政策性银行|国家开发银行||
||进出口银行||
||中国农业发展银行||
|国有银行和商业银行|中国银行||
||中国农业银行||
||中国工商银行||
||中国建设银行||
||中国邮政||
||招商银行||
||平安||
||浦发||
||广发||
||中信||
|外资银行|汇丰银行||
||渣打银行||
|金融结算，交易服务|中国银联总部||
||中国网联||
||银联商务||
||（上海、深圳）证券交易所||
||中国人民银行清算中心||
|证券公司|华泰联合证券||
||广发证券||
|电力|国家电网||
||国家电网科学院（南瑞集团）||
||电网子公司||
|发电（四大集团）|大唐集团科学院||
||华润集团||
||神华集团||
||中国核电||
|医院|||
|铁路，航空公司|铁路局，中国铁道科学院，航空公司，||
|汽车|||
|三大运营商及其通信公司|联通软件研究院||
||中移互联网/中移在线||
||电信||
|外企/互联网公司|Google||
||IBM||
||ORACLE||
||微软||
||红帽||
||万革始||
||SAP||
||intel||
||ThoughtWorks||
||三星||
||华为||
|一线|BAT TMD||
|二线|去哪儿||
||携程||
||...||
|三线|一个app撑一个公司||
|创业公司|画饼||
|独角兽|商汤||
|传统/制造业|旷视科技||
||深信服||
||新华三等||
||浪潮集团||
||龙湖地产科技部||
||顺丰科技||
||大疆科技||
||格力电器||
